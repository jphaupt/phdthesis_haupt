\chapter{The PyTCHInt Library}
\label{chap:pytchint}

This chapter is based on the following software, to be released:\\
\fullcite{tchint}

The basis for how the library works is partially discussed in the following paper and its supplementary material: \\
\fullcite{cohenSimilarity2019}

\section{Introduction}

All transcorrelated matrix element calculations presented in this dissertation have been performed using the group's \tchint library or its Python extension, \pytchint. This library works by either producing transformed integral files, dubbed \fcidump files for four-index integrals,\todo{citation} or \tcdump files for the \gls{TC} six-index integrals. Note that since the \gls{TC} transformation is non-Hermitian, we do not have the same symmetries in these files as we do with conventional methods, or by interfacing with another program (such as \neci) or the Python interpreter (in the case of \pytchint).

As described in section \ref{sec:tc},
\begin{equation}
    \htc = \sum_{pq} h_q^p a_p^\dagger a_q
    + \frac{1}{2} \sum_{pqrs} \big(V_{rs}^{pq} - K_{rs}^{pq}\big)
    a_p^\dagger a_q^\dagger a_s a_r
    - \frac{1}{6} \sum_{pqrstu} L_{stu}^{pqr}
    a_p^\dagger a_q^\dagger a_r^\dagger a_u a_t a_s,
\end{equation}
where
\begin{equation}
\begin{split}
    h_q^p &= \bra{p}h\ket{q}, \\
    V_{rs}^{pq} &= \bra{p q } r_{12}^{-1} \ket{ r s}, \\
    K_{rs}^{pq} &= \bra{p q } \hat{K} \ket{ r s}, \\
    L_{stu}^{pqr} &= \bra{p q r } \hat{L} \ket{s t u}.
\end{split}
\end{equation}
$h_q^p$ and $V_{rs}^{pq}$ are the one- and two-body terms from the electronic Schr\"odinger equation, familiar from conventional methods. Therefore, the key quantities to be evaluated by \tchint are the non-Hermitian two-body integrals $K_{rs}^{pq}$ and the Hermitian three-body integrals $L_{stu}^{pqr}$.

Once these integrals are evaluated, as long as we take care about using the correct bra and ket (a detail not important for Hermitian problems), many different methodologies can be applied with these integrals, such as the frozen-core approximation,\todo{citation(s)} or \gls{xTC}.\todo{citation}

\section{Matrix Element Evaluation}
The matrix elements not present in conventional methods are $K_{rs}^{pq}$ and $L_{stu}^{pqr}$. For these, we integrate on a grid, typically Treutler-Ahlrichs integration grids,
\supercite{beckeMulticenter1988,treutlerEfficient1995} which are atom-centred grids commonly used in density functional theory. These grids are obtained via \pyscf.

The two-electron matrix elements we need to evaluate are:
\begin{align}
    K_{rs}^{pq(1)} &= \bra{pq}\nabla_1u(\bm r_1, \bm r_2)\cdot\nabla_1\ket{rs}\\
    K_{rs}^{pq(2)} &= \bra{pq}\nabla_1^2u(\bm r_1, \bm r_2)\ket{rs}\\
    K_{rs}^{pq(3)} &= \bra{pq}(\nabla_1u(\bm r_1, \bm r_2))^2\ket{rs}.
\end{align}
Discretising on a grid of $N_\mathrm{grid}$ points with weights $w$, we have
\begin{equation}
    K_{rs}^{pq(1)} = \sum_{mn}^{N_\mathrm{grid}}
    \phi_p(\bm r_m)\nabla_{\bm r_m}\phi_r(\bm r_m)\cdot \nabla_{\bm r_m}u(\bm r_m, \bm r_n)\phi_q(\bm r_n)\phi_s(\bm r_n)w(\bm r_m)w(\bm r_n).
\end{equation}
Naive integration of this value yields $\mathcal{O}(N_\mathrm{grid}M^4)$ performance (where $M$ is the number of basis functions). However, we may improve this by first integrating over one coordinate and storing the intermediate value. Moreover, for $K_{rs}^{pq(2)}$, it is more efficient to integrate by parts. Therefore, for the full $K$ matrix, we calculate the intermediate value
\begin{align}
    X_s^q(\bm r_2) =& \int\d r_1\ \nabla_1u(\bm r_1, \bm r_2)\cdot[\phi_p(\bm r_1) \nabla_1\phi_r(\bm r_1) - \phi_r(\bm r_1)
\nabla_1\phi_p(\bm r_1)]  \\
&+ \int\d r_1\ \phi_p(\bm r_1)(\nabla u(\bm r_1, \bm r_2))^2 \phi_r(\bm r_1).
\end{align}
We can then obtain the $K$ matrix by
\begin{equation}
    K_{rs}^{pq} = \int\d r_2\ \phi_q(\bm r_2)X_s^q(\bm r_2)\phi_s(\bm r_2)
\end{equation}
for a cost of $\mathcal{O}(N_\mathrm{grid}^2M^2+N_\mathrm{grid}M^4)$.

\gls{MPI}\todo{citations} and OpenMP\todo{citations}

\todo{mention the different ``intermediate'' quantities, RI (no longer really used), xTC}

\todo{mention the existence of many different options, sprase L, xtc, periodic solids, etc}

\todo{mention that with xtc we no longer need }

\section{Interface}
\todo{NECI interface, M7 interface, pytchint and interactive HPC}

\section{Deterministic Optimisation}

\todo{mention it uses the interface for existing high-performing optimisation packages, rapid prototyping}

\section{Performance}
\todo{not really sure how I'll write this section, since I don't really have a performance metric to go up against}
\todo{parallel efficiency}
\todo{memory requirements, with vs without xTC}
\todo{mention other smaller details, such as never calculating the L matrix during xTC}
\todo{memory requirements, e.g. full TC, no-3-body, xTC}
\todo{pytchint vs tchint performance}
\todo{mention use of BLAS routines}

\section{Conclusion and Outlook}
\todo{mention GPU acceleration, Python libraries, JAX (+ AD?), deterministic optimisation, interfacing with other QMC libraries ...}
